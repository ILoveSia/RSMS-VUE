# RSMS_VUE 인프라 구성 설명

## 목차
1. [Vite 개념](#1-vite-개념)
2. [Node.js + Express vs Spring Boot](#2-nodejs--express-vs-spring-boot)
3. [운영 환경 구성](#3-운영-환경-구성)
4. [포트 구성](#4-포트-구성)
5. [HTTP vs HTTPS](#5-http-vs-https)
6. [SSL 인증서 설정](#6-ssl-인증서-설정)
7. [서버 확장 전략](#7-서버-확장-전략)
8. [PM2 클러스터 + Redis 구성](#8-pm2-클러스터--redis-구성)

---

## 1. Vite 개념

### Vite란?
**Vite**(비트)는 Vue.js 프로젝트의 **빌드 도구**입니다.

### Vue vs Vite
- **Vue**: 프레임워크 (집을 짓는 설계도)
- **Vite**: 빌드 도구 (건설 장비 - 빠르게 집을 짓는 도구)

### 개발 환경에서 Vite의 역할

```
개발 모드 (npm run dev):
  ┌─────────────────────────────────┐
  │  Vite 개발 서버 (localhost:5173) │
  │  - 즉시 시작 (빠른 콜드 스타트)   │
  │  - HMR (Hot Module Replacement)  │
  │  - 실시간 코드 변경 반영          │
  └─────────────────────────────────┘
```

### 운영 환경에서 Vite의 역할

```bash
# 빌드 명령
npm run build

# 결과물
frontend/
  └── dist/              # Vite가 생성한 배포 파일
       ├── index.html
       ├── assets/
       │    ├── index-abc123.js    # 압축된 JavaScript
       │    └── index-def456.css   # 압축된 CSS
       └── favicon.ico
```

### Vite의 주요 기능
1. **빠른 개발 서버 시작**: 전통적인 번들러 대비 10-100배 빠름
2. **HMR (Hot Module Replacement)**: 코드 수정 시 페이지 새로고침 없이 즉시 반영
3. **최적화된 빌드**: Rollup 기반 프로덕션 빌드로 최적화된 결과물 생성
4. **ES 모듈 지원**: 최신 JavaScript 표준 활용

---

## 2. Node.js + Express vs Spring Boot

### 기본 구조 비교

| 특징 | Node.js + Express | Spring Boot |
|------|-------------------|-------------|
| 언어 | JavaScript | Java |
| 실행 방식 | 단일 스레드 (이벤트 기반) | 멀티 스레드 (요청당 스레드) |
| 메모리 사용 | 적음 (~50-100MB) | 많음 (~200-500MB) |
| 시작 속도 | 빠름 (1-2초) | 느림 (5-10초) |
| 개발 생산성 | 높음 (간결한 코드) | 보통 (타입 안정성) |
| 확장성 | 수평 확장 권장 | 수직/수평 확장 모두 가능 |

### 요청 처리 방식

**Node.js + Express (이벤트 루프)**:
```
하나의 프로세스:
  요청1 → 이벤트 큐 → 비동기 처리 → 응답1
  요청2 → 이벤트 큐 → 비동기 처리 → 응답2
  요청3 → 이벤트 큐 → 비동기 처리 → 응답3

특징: I/O 대기 시간 동안 다른 요청 처리 가능
```

**Spring Boot (멀티 스레드)**:
```
여러 개의 스레드:
  요청1 → 스레드1 → 처리 → 응답1
  요청2 → 스레드2 → 처리 → 응답2
  요청3 → 스레드3 → 처리 → 응답3

특징: 각 요청을 별도 스레드에서 처리
```

### 선택 기준
- **Node.js + Express 추천**: I/O 중심 (API, 실시간 통신, 가벼운 서비스)
- **Spring Boot 추천**: CPU 중심 (복잡한 비즈니스 로직, 대용량 트랜잭션)

---

## 3. 운영 환경 구성

### 전통적인 구성 (Spring Boot 기반)
```
┌─────────────────────────────────────┐
│  Web 서버 (Nginx/Apache)             │
│  - 정적 파일 서빙 (HTML, CSS, JS)    │
│  - 리버스 프록시                     │
└──────────┬──────────────────────────┘
           ↓
┌──────────┴──────────────────────────┐
│  WAS (Tomcat/Spring Boot)            │
│  - 동적 컨텐츠 처리                  │
│  - 비즈니스 로직                     │
└──────────┬──────────────────────────┘
           ↓
┌──────────┴──────────────────────────┐
│  Database (PostgreSQL)               │
└─────────────────────────────────────┘
```

### Node.js + Express 구성 (우리 프로젝트)

#### 방법 1: Node.js 단독 구성 (간단)
```
┌─────────────────────────────────────┐
│  서버 1대                            │
│                                     │
│  [Node.js :5000]                    │
│    ├─ 정적 파일 서빙 (Vue 빌드 결과) │
│    └─ API 처리                      │
│           ↓                         │
│  [PostgreSQL :5432]                 │
└─────────────────────────────────────┘
```

**장점**: 설정 간단, 서버 하나만 관리
**단점**: 성능 제한, SSL 설정 복잡

#### 방법 2: Nginx + Node.js 구성 (권장)
```
┌─────────────────────────────────────┐
│  서버 1대                            │
│                                     │
│  [Nginx :80, :443]                  │
│    ├─ 정적 파일 서빙 (Vue)           │
│    ├─ SSL/HTTPS 처리                │
│    └─ /api/* → localhost:5000 프록시│
│           ↓                         │
│  [Node.js :5000]                    │
│    └─ API 처리만 담당                │
│           ↓                         │
│  [PostgreSQL :5432]                 │
└─────────────────────────────────────┘
```

**장점**: 성능 우수, SSL 설정 쉬움, 보안 강화
**단점**: 설정 복잡, Nginx 추가 관리 필요

---

## 4. 포트 구성

### 하나의 물리 서버에서 포트 분리

```
서버 IP: 192.168.1.100

┌─────────────────────────────────────┐
│  포트 80 (HTTP)                      │
│  └─ Nginx → HTTPS로 리다이렉트       │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  포트 443 (HTTPS)                    │
│  └─ Nginx → 정적 파일 + API 프록시   │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  포트 5000 (내부 전용)               │
│  └─ Node.js (외부 접근 차단)         │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  포트 5432 (내부 전용)               │
│  └─ PostgreSQL (외부 접근 차단)      │
└─────────────────────────────────────┘
```

### 방화벽 설정
```bash
# 외부 접근 허용
포트 80 (HTTP)   ✅ 허용
포트 443 (HTTPS) ✅ 허용

# 외부 접근 차단
포트 5000 (Node.js)    ❌ 차단 (내부만)
포트 5432 (PostgreSQL) ❌ 차단 (내부만)
```

---

## 5. HTTP vs HTTPS

### 포트 비교
- **HTTP**: 80번 포트 (암호화 없음)
- **HTTPS**: 443번 포트 (SSL/TLS 암호화)

### 동시 사용 가능
HTTP와 HTTPS는 **동시에 사용 가능**하며, 일반적으로 HTTP를 HTTPS로 리다이렉트합니다.

```nginx
# Nginx 설정 예시
server {
    listen 80;
    server_name your-domain.com;

    # HTTP → HTTPS 리다이렉트
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl;
    server_name your-domain.com;

    # SSL 인증서 설정
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;

    # 실제 서비스
    location / {
        root /var/www/rsms-vue/frontend/dist;
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://localhost:5000;
    }
}
```

### 일반적인 구성 전략
1. **개발 환경**: HTTP만 사용 (localhost)
2. **운영 환경**: HTTP + HTTPS (HTTP는 HTTPS로 리다이렉트)

---

## 6. SSL 인증서 설정

### 인증서 종류

#### 1. Let's Encrypt (무료, 권장)
```bash
# Certbot 설치 (Ubuntu/Debian)
sudo apt update
sudo apt install certbot python3-certbot-nginx

# SSL 인증서 발급 (Nginx 자동 설정)
sudo certbot --nginx -d your-domain.com

# 자동 갱신 설정 (인증서는 90일마다 만료)
sudo certbot renew --dry-run
```

**장점**:
- 완전 무료
- 자동 갱신 (cron job으로 설정)
- 신뢰도 높음 (모든 브라우저에서 인정)

**단점**:
- 90일마다 갱신 필요 (자동화 필수)
- 와일드카드 인증서는 DNS 검증 필요

#### 2. 상용 인증서 (유료)
- **Comodo**: 연간 $50-200
- **DigiCert**: 연간 $200-1000
- **GlobalSign**: 연간 $100-500

**장점**:
- 기업 신뢰도 높음
- 1-2년 유효기간
- 기술 지원 제공

**단점**:
- 비용 발생
- 갱신 절차 복잡

### 추천 방식
- **소규모/개인 프로젝트**: Let's Encrypt
- **기업/금융 서비스**: 상용 인증서 (EV 인증서)

---

## 7. 서버 확장 전략

### 사용자 증가에 따른 대응 전략

```
┌──────────────────────────────────────────┐
│ 단계 1: 성능 최적화 (100명 이하)          │
│ - 코드 최적화                            │
│ - DB 쿼리 최적화                         │
│ - Redis 캐싱 도입                        │
└──────────────────────────────────────────┘
                   ↓
┌──────────────────────────────────────────┐
│ 단계 2: 수직 확장 (100-500명)            │
│ - CPU 업그레이드 (2 → 4 코어)            │
│ - RAM 증설 (4GB → 8GB)                  │
│ - PM2 클러스터 모드                      │
└──────────────────────────────────────────┘
                   ↓
┌──────────────────────────────────────────┐
│ 단계 3: 수평 확장 (500명 이상)           │
│ - 서버 추가 (2대 이상)                   │
│ - 로드 밸런서 도입                       │
│ - DB 복제 (Master-Slave)                │
└──────────────────────────────────────────┘
```

### A. 수직 확장 (Vertical Scaling)
**하나의 서버 성능 업그레이드**

```bash
# PM2 클러스터 모드로 CPU 활용 극대화
pm2 start server.js -i max  # CPU 코어 수만큼 프로세스 생성
```

**예시**:
- CPU: 2 코어 → 4 코어
- RAM: 4GB → 8GB
- 디스크: HDD → SSD

**장점**: 설정 간단, 관리 용이
**단점**: 한계 존재, 비용 증가

### B. 수평 확장 (Horizontal Scaling)
**여러 서버로 분산**

```
                [로드 밸런서]
                      |
        ┌─────────────┼─────────────┐
        ↓             ↓             ↓
   [서버 1]       [서버 2]       [서버 3]
   Node.js       Node.js       Node.js
        └─────────────┼─────────────┘
                      ↓
              [공유 DB + Redis]
```

**Nginx 로드 밸런서 설정**:
```nginx
upstream backend {
    server 192.168.1.101:5000;  # 서버 1
    server 192.168.1.102:5000;  # 서버 2
    server 192.168.1.103:5000;  # 서버 3
}

server {
    listen 80;
    location /api {
        proxy_pass http://backend;
    }
}
```

**장점**: 무제한 확장 가능, 고가용성
**단점**: 설정 복잡, 상태 동기화 필요

---

## 8. PM2 클러스터 + Redis 구성

### PM2 클러스터 모드

**하나의 서버에서 여러 Node.js 프로세스 실행**

```bash
# CPU 코어 수만큼 자동 생성 (권장)
pm2 start server.js -i max

# 수동으로 프로세스 수 지정
pm2 start server.js -i 4
```

**동작 방식**:
```
서버 (CPU 4코어)
  ├─ Node.js 프로세스 1 (포트 5000)
  ├─ Node.js 프로세스 2 (포트 5000)
  ├─ Node.js 프로세스 3 (포트 5000)
  └─ Node.js 프로세스 4 (포트 5000)
         ↓
    [로드 밸런싱]
         ↓
    요청 분산 처리
```

### Redis 구성 (중요)

**Redis는 1개만 가동합니다!**

```
┌─────────────────────────────────────┐
│  PM2 클러스터 (4개 프로세스)         │
│  ├─ Node.js 프로세스 1 ──┐          │
│  ├─ Node.js 프로세스 2 ──┤          │
│  ├─ Node.js 프로세스 3 ──┼─> [Redis 1개]
│  └─ Node.js 프로세스 4 ──┘          │
└─────────────────────────────────────┘
```

### Redis 설치 및 설정

```bash
# Redis 설치 (Ubuntu/Debian)
sudo apt update
sudo apt install redis-server

# Redis 시작 및 자동 시작 설정
sudo systemctl start redis-server
sudo systemctl enable redis-server

# Redis 연결 확인
redis-cli ping
# 응답: PONG
```

### Node.js에서 Redis 연결

```bash
# Redis 클라이언트 설치
npm install redis
```

```javascript
// backend/config/redis.js
const redis = require('redis');

const client = redis.createClient({
  host: 'localhost',
  port: 6379
});

client.on('connect', () => {
  console.log('Redis 연결 성공');
});

client.on('error', (err) => {
  console.error('Redis 에러:', err);
});

module.exports = client;
```

### 캐싱 예시

```javascript
// backend/services/organizationService.js
const redisClient = require('../config/redis');

async function getOrganizations() {
  // 1. Redis 캐시 확인
  const cacheKey = 'organizations:all';
  const cached = await redisClient.get(cacheKey);

  if (cached) {
    console.log('캐시에서 반환');
    return JSON.parse(cached);
  }

  // 2. DB에서 조회
  const data = await organizationRepository.findAll();

  // 3. Redis에 캐싱 (5분 TTL)
  await redisClient.setex(cacheKey, 300, JSON.stringify(data));

  return data;
}
```

### 성능 향상 효과

| 구성 | 처리량 (req/sec) | 응답 시간 |
|------|------------------|-----------|
| Node.js 단일 프로세스 | 500 | 200ms |
| PM2 클러스터 (4 프로세스) | 2000 | 50ms |
| PM2 + Redis 캐싱 | 5000 | 10ms |

---

## 요약

### 개발 환경
```
Frontend: Vite 개발 서버 (localhost:5173)
Backend: Node.js + Express (localhost:5000)
Database: PostgreSQL (172.21.174.2:5432)
```

### 운영 환경 (권장)
```
포트 80: Nginx (HTTP → HTTPS 리다이렉트)
포트 443: Nginx (HTTPS, 정적 파일 + API 프록시)
포트 5000: Node.js + Express (내부 전용)
포트 5432: PostgreSQL (내부 전용)
포트 6379: Redis (내부 전용)
```

### 확장 전략
1. **소규모 (<100명)**: Node.js 단독 + Redis 캐싱
2. **중규모 (100-500명)**: Nginx + PM2 클러스터 + Redis
3. **대규모 (500명+)**: 로드 밸런서 + 다중 서버 + Redis Cluster

### 핵심 포인트
- **Vite**: 빌드 도구 (개발 서버 + 프로덕션 빌드)
- **Node.js**: 이벤트 기반, 가볍고 빠름
- **Nginx**: 정적 파일 서빙 + 리버스 프록시 + SSL 처리
- **PM2 클러스터**: CPU 코어 수만큼 프로세스 생성
- **Redis**: 1개만 설치, 모든 Node.js 프로세스가 공유
- **Let's Encrypt**: 무료 SSL 인증서, 자동 갱신
